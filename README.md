# Лабораторная работа №2

**Постановка задачи**

Списки в языке Kotlin — это коллекции, которые могут быть неизменяемыми или изменяемыми, хранящие элементы заданного типа. Для объявления списка и его инициализации используется следующий синтаксис:
```Kotlin
val имяСписка = listOf(элемент1, элемент2, …, элементN);
```

Примеры:
1.	Список строк – последовательность строковых значений, например:
```Kotlin
val fruits = listOf(“a”, “b”, “c”);
```
В связи с разработанной автоматной грамматикой G[<List>], лексер будет считать верными следующие записи списка:
```Kotlin
val names = listOf("apple", "banana", "cherry");
```


**Персональный вариант задания на лабораторную работу**

Выполнить программную реализацию алгоритма синтаксического анализа объявления списка с инициализацией на Kotlin.
```Kotlin
val animals = listOf("Dog", "Cat", "Cow");
```


**Примеры допустимых строк**
```Kotlin
val names = listOf("apple", "banana", "cherry");
```
```Kotlin
val fruits = listOf(“a”, “b”, “c”);
```

**Диаграмма состояний сканера и тестовые примеры.**

![image](https://github.com/user-attachments/assets/2b98bfcf-a2ce-482c-988a-0dbd2b39f68f)
![image](https://github.com/user-attachments/assets/f30d2066-c4ed-4001-8c93-63247813970b)
![image](https://github.com/user-attachments/assets/9cfe5d00-d82e-43a2-874c-98147ddd3960)


# Лабораторная работа №3

**Вариант задания**

Выполнить программную реализацию алгоритма синтаксического анализа объявления списка с инициализацией на Kotlin.
```Kotlin
val animals = listOf("Dog", "Cat", "Cow");
```

**Примеры допустимых строк**
```Kotlin
val names = listOf("apple", "banana", "cherry");
```
```Kotlin
val fruits = listOf(“a”, “b”, “c”);
```

**Разработанная грамматика**
Определим грамматику объявления списка с инициализацией языка Kotlin G[<List>] в нотации Хомского с продукциями P:
```
1.	‹List› → ‘val’‹I›
2.	‹I› → ‘ ’‹ID›
3.	‹ID› → ‹Letter›‹IR›
4.	‹IR› → ‹Letter›‹IR›
5.	‹IR› → ‘=’‹O›
6.	‹O› → ‘listOf’‹L›
7.	‹L› → ‘(’‹A›
8.	‹A› → ‘‘‘’‹S›
9.	‹S› → ‹Symbols›‹SR›
10.	‹SR› → ‹Symbols›‹SR›
11.	‹S› → ‘’’’‹ES›
12.	‹ES› → ‘,’‹A›
13.	‹ES› → ‘)’‹E›
14.	‹E› → ‘;’
•	‹Symbols› → “0” | “1” | “2” | ... | “9” | “a” | “b” | “c” | ... | “z” | “A” | “B” | “C” | ... | “Z” | “~” | “`” | “!” | “@” | “#” | “№” | “$” | “%” | “^” | “:” | “?” | “&” | “*” | “(” | “)” | “-” | “+” | “=” | “‘” | “’” | “/” | “\” | “|” | “<” | “>” | “_” | “ ”
•	‹Letter› → “a” | “b” | “c” | ... | “z” | “A” | “B” | “C” | ... | “Z”
Следуя введенному формальному определению грамматики, представим G[‹List›] ее составляющими:
•	Z = ‹List›;
•	VT = {a, b, c, ..., z, A, B, C, ..., Z, =, +, -, ;, ., 0, 1, 2, ..., 9};
•	VN = {‹IR›, ‹L›, ‹A›, ‹S›, ‹SR›, ‹ES›, ‹E›}.
```

**Классификация грамматики**

Согласно классификации Хомского, грамматика G[‹List›] является автоматной.
Праворекурсивные правила:
Правила, где рекурсивный вызов нетерминала находится в крайней правой позиции, что соответствует форме A → aB.
В данной грамматике такими являются:
```
(4) ‹IR› → ‹Letter›‹IR›
(10) ‹SR› → ‹Symbols›‹SR›
```
Остальные правила не содержат рекурсии или завершают цепочку продукций терминальным символом (правило ```(14) ‹E› → ‹;›```).

Поскольку все правила продукции имеют форму либо A → aB, либо A → a, грамматика является праворекурсивной и, следовательно, соответствует автоматной грамматике (регулярной грамматике, тип-3 по классификации Хомского). Это удовлетворяет требованию о том, что все правила должны быть либо леворекурсивными, либо праворекурсивными – в нашем случае они однородно праворекурсивные.

**Граф конечного автомата**

![image](https://github.com/user-attachments/assets/b4aad3c1-286f-4604-b71d-c5ad368384a9)

**Тестовые примеры**

![image](https://github.com/user-attachments/assets/33e40b1c-3f73-44b3-ba4b-f2e95dc3ca9c)
![image](https://github.com/user-attachments/assets/13c57a09-0045-4472-85f3-2fbd57c3ecb9)


# Лабораторная работа №4

**Вариант задания**

Выполнить программную реализацию алгоритма синтаксического анализа объявления списка с инициализацией на Kotlin.
```Kotlin
val animals = listOf("Dog", "Cat", "Cow");
```

**Примеры допустимых строк**
```Kotlin
val names = listOf("apple", "banana", "cherry");
```
```Kotlin
val fruits = listOf(“a”, “b”, “c”);
```

**Разработанная грамматика**
Определим грамматику объявления списка с инициализацией языка Kotlin G[<List>] в нотации Хомского с продукциями P:
```
1.	‹List› → ‘val’‹I›
2.	‹I› → ‘ ’‹ID›
3.	‹ID› → ‹Letter›‹IR›
4.	‹IR› → ‹Letter›‹IR›
5.	‹IR› → ‘=’‹O›
6.	‹O› → ‘listOf’‹L›
7.	‹L› → ‘(’‹A›
8.	‹A› → ‘‘‘’‹S›
9.	‹S› → ‹Symbols›‹SR›
10.	‹SR› → ‹Symbols›‹SR›
11.	‹S› → ‘’’’‹ES›
12.	‹ES› → ‘,’‹A›
13.	‹ES› → ‘)’‹E›
14.	‹E› → ‘;’
•	‹Symbols› → “0” | “1” | “2” | ... | “9” | “a” | “b” | “c” | ... | “z” | “A” | “B” | “C” | ... | “Z” | “~” | “`” | “!” | “@” | “#” | “№” | “$” | “%” | “^” | “:” | “?” | “&” | “*” | “(” | “)” | “-” | “+” | “=” | “‘” | “’” | “/” | “\” | “|” | “<” | “>” | “_” | “ ”
•	‹Letter› → “a” | “b” | “c” | ... | “z” | “A” | “B” | “C” | ... | “Z”
Следуя введенному формальному определению грамматики, представим G[‹List›] ее составляющими:
•	Z = ‹List›;
•	VT = {a, b, c, ..., z, A, B, C, ..., Z, =, +, -, ;, ., 0, 1, 2, ..., 9};
•	VN = {‹IR›, ‹L›, ‹A›, ‹S›, ‹SR›, ‹ES›, ‹E›}.
```

**Классификация грамматики**

Согласно классификации Хомского, грамматика G[‹List›] является автоматной.
Праворекурсивные правила:
Правила, где рекурсивный вызов нетерминала находится в крайней правой позиции, что соответствует форме A → aB.
В данной грамматике такими являются:
```
(4) ‹IR› → ‹Letter›‹IR›
(10) ‹SR› → ‹Symbols›‹SR›
```
Остальные правила не содержат рекурсии или завершают цепочку продукций терминальным символом (правило ```(14) ‹E› → ‹;›```).

Поскольку все правила продукции имеют форму либо A → aB, либо A → a, грамматика является праворекурсивной и, следовательно, соответствует автоматной грамматике (регулярной грамматике, тип-3 по классификации Хомского). Это удовлетворяет требованию о том, что все правила должны быть либо леворекурсивными, либо праворекурсивными – в нашем случае они однородно праворекурсивные.

**Граф конечного автомата**

![image](https://github.com/user-attachments/assets/b4aad3c1-286f-4604-b71d-c5ad368384a9)

**Тестовые примеры**

![image](https://github.com/user-attachments/assets/33e40b1c-3f73-44b3-ba4b-f2e95dc3ca9c)
![image](https://github.com/user-attachments/assets/13c57a09-0045-4472-85f3-2fbd57c3ecb9)
